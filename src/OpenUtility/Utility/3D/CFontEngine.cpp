#include <stdlib.h>#include <string.h>#include <png.h>#include "CFontEngine.h"#include "../FileSystem/FileHandling.h"OpenUtility::CRedBlackTree<OpenUtility::CFontLoader::CFontId,OpenUtility::CFontLoader::CFontData*> OpenUtility::CFontLoader::FontTree;bool OpenUtility::CFontLoader::CFontId::operator<(const CFontId &obj) const{	if (FontName<obj.FontName) return(true);	if (FontName==obj.FontName)	{		if (FontStyle<obj.FontStyle) return(true);		if (FontStyle==obj.FontStyle)		{			if (FontSize<obj.FontSize) return(true);		}	}	return(false);}OpenUtility::CFontLoader::CFontData::CFontData(CFontId &fId) :	FontId(fId),	FontTexture(NULL),	nbInUse(0),	KeepLoaded(false){	memset(CharsData,0,sizeof(CharsData));}OpenUtility::CFontLoader::CFontLoader(const char *font,unsigned int size,const char *cache,bool keepLoaded) :	pFontData(NULL){	FT_Library library;	FT_Face face;	if (FT_Init_FreeType(&library)) return;	if (FT_New_Face(library,font,0,&face)) return;	CFontId fontId(face->family_name,face->style_name,size);	try	{		pFontData=FontTree[fontId];	}	catch(typename OpenUtility::CRedBlackTree<OpenUtility::CFontLoader::CFontId,OpenUtility::CFontLoader::CFontData*>::Exception &e)	{		if (e.GetError()!=OpenUtility::CRedBlackTree<OpenUtility::CFontLoader::CFontId,CFontData*>::Exception::EErrNotFound) throw;	}	if (pFontData==NULL)	{		CStream file;		if (cache) file=cache;		else file='.';		file.AddFormatStream("/%s.%s.%u.font",face->family_name,face->style_name,size);		if (!isFile(file.GetStream())) pFontData=GenFont(face,file,size,fontId);		else pFontData=ReadFont(file,fontId);		if (pFontData) FontTree.Add(fontId,pFontData);	}	FT_Done_FreeType(library);	if (pFontData)	{		pFontData->nbInUse++;		if (keepLoaded) pFontData->KeepLoaded=true;	}}OpenUtility::CFontLoader::~CFontLoader(){	if (pFontData)	{		pFontData->nbInUse--;		if (pFontData->nbInUse==0 && !pFontData->KeepLoaded)		{			delete(FontTree.Remove(pFontData->FontId));		}	}}OpenUtility::CFontLoader::CFontLoader(const CFontLoader &obj){	pFontData=obj.pFontData;	if (pFontData) pFontData->nbInUse++;}OpenUtility::CFontLoader& OpenUtility::CFontLoader::operator=(const CFontLoader &obj){	if (pFontData!=obj.pFontData)	{		if (pFontData)		{			pFontData->nbInUse--;			if (pFontData->nbInUse==0 && !pFontData->KeepLoaded)			{				delete(FontTree.Remove(pFontData->FontId));			}		}		pFontData=obj.pFontData;		if (pFontData) pFontData->nbInUse++;	}	return(*this);}unsigned int OpenUtility::CFontLoader::GetSize() const{	if (!pFontData) THROW(Exception,Exception::EErrBadInit);	return(pFontData->GetSize());}const OpenUtility::CTexture* OpenUtility::CFontLoader::GetFontTexture() const{	if (!pFontData) THROW(Exception,Exception::EErrBadInit);	return(pFontData->GetFontTexture());}const OpenUtility::CFontLoader::SFontChar* OpenUtility::CFontLoader::GetCharData(unsigned char c) const{	if (!pFontData) THROW(Exception,Exception::EErrBadInit);	return(pFontData->GetCharData(c));}int OpenUtility::CFontLoader::GetFile16b(FILE *fp){	int c,val;	val=0;	c=fgetc(fp);	if (!feof(fp)) val|=c<<8;	c=fgetc(fp);	if (!feof(fp)) val|=c;	return(val);}void OpenUtility::CFontLoader::PutFile16b(FILE *fp,int val){	fputc((val>>8)&0xff,fp);	fputc(val&0xff,fp);}OpenUtility::CFontLoader::CFontData* OpenUtility::CFontLoader::ReadFont(CStream &file,CFontId &fId){	unsigned char header[6];	unsigned int i,nbChar;	FILE *fp;	if ((fp=fopen(file.GetStream(),"r"))==NULL) return(NULL);	// read the header	if ((fread(header,1,6,fp)!=6) || (memcmp(header,"OUFONT",6)!=0)) return(NULL);	nbChar=GetFile16b(fp);	if (nbChar>256) return(NULL);	CFontData *fontData=new CFontData(fId);	for (i=0;i<nbChar;i++)	{		fontData->CharsData[i].Advance=GetFile16b(fp);		if (feof(fp))		{			fclose(fp);			delete fontData;			return(NULL);		}		if (fontData->CharsData[i].Advance==0) continue;		fontData->CharsData[i].texW=GetFile16b(fp);		fontData->CharsData[i].texH=GetFile16b(fp);		fontData->CharsData[i].BearingX=GetFile16b(fp);		fontData->CharsData[i].BearingY=GetFile16b(fp);		fontData->CharsData[i].texX=GetFile16b(fp);		fontData->CharsData[i].texY=GetFile16b(fp);	}	unsigned char *buffer;	unsigned int width,height;	if ((buffer=ReadPngBitmap(fp,width,height))==NULL)	{		delete fontData;		return(NULL);	}	fclose(fp);	fontData->FontTexture=CTexture::LoadTextureMemory(buffer,width,height,CTexture::EPModeG);	free(buffer);	return(fontData);}OpenUtility::CFontLoader::CFontData* OpenUtility::CFontLoader::GenFont(FT_Face face,CStream &file,unsigned int size,CFontId &fId){	const int sizeTW=512;	if (FT_Set_Pixel_Sizes(face,0,size)) return(NULL);	FT_GlyphSlot slot=face->glyph;	int w,h,x=0,y=0,tmp=0;	for (unsigned int n=0;n<256;n++)	{		FT_UInt glyph_index=FT_Get_Char_Index(face,n);		if ((glyph_index==0) || FT_Load_Glyph(face,glyph_index,FT_LOAD_DEFAULT)) continue;		w=slot->metrics.width>>6;		h=slot->metrics.height>>6;		if (w>sizeTW) return(NULL);		if (x+w>sizeTW)		{			x=0;			y+=tmp+1;			tmp=0;		}		if (tmp<h) tmp=h;		x+=w+1;	}	if (y>0) x=sizeTW;	y+=tmp+1;	unsigned char *buffer;	unsigned int width,height;	CFontData *fontData=new CFontData(fId);	FILE *fp;	if ((fp=fopen(file.GetStream(),"w"))==NULL) return(NULL);	fprintf(fp,"OUFONT");	PutFile16b(fp,256);	width=x;	height=y;	if ((buffer=(unsigned char*)calloc(width*height,sizeof(unsigned char)))==NULL)	{		delete fontData;		return(NULL);	}	x=0;	y=0;	tmp=0;	for (unsigned int n=0;n<256;n++)	{		FT_UInt glyph_index=FT_Get_Char_Index(face,n);		if ((glyph_index==0) || FT_Load_Glyph(face,glyph_index,FT_LOAD_RENDER))		{			fontData->CharsData[n].Advance=0;			PutFile16b(fp,0);			continue;		}		w=slot->metrics.width>0 ? slot->metrics.width>>6 : 0;		h=slot->metrics.height>0 ? slot->metrics.height>>6 : 0;		if (slot->bitmap.width!=w || slot->bitmap.rows!=h)		{			printf("erreur font size !!!\n");			fclose(fp);			delete fontData;			return(NULL);		}		if (x+w>sizeTW)		{			x=0;			y+=tmp+1;			tmp=0;		}		if (tmp<h) tmp=h;		PutFile16b(fp,fontData->CharsData[n].Advance=slot->metrics.horiAdvance>0 ? slot->metrics.horiAdvance>>6 : 0);		PutFile16b(fp,fontData->CharsData[n].texW=w);		PutFile16b(fp,fontData->CharsData[n].texH=h);		PutFile16b(fp,fontData->CharsData[n].BearingX=slot->metrics.horiBearingX>0 ? slot->metrics.horiBearingX>>6 : 0);		PutFile16b(fp,fontData->CharsData[n].BearingY=slot->metrics.horiBearingY ? slot->metrics.horiBearingY>>6 : 0);		PutFile16b(fp,fontData->CharsData[n].texX=x);		PutFile16b(fp,fontData->CharsData[n].texY=y);		for (int i=0;i<slot->bitmap.rows;i++)			memcpy(&buffer[x+(y+i)*width],&slot->bitmap.buffer[i*slot->bitmap.pitch],slot->bitmap.width);		x+=w+1;	}	WritePngBitmap(fp,buffer,width,height);	fclose(fp);	fontData->FontTexture=CTexture::LoadTextureMemory(buffer,width,height,CTexture::EPModeG);	free(buffer);	return(fontData);}bool OpenUtility::CFontLoader::WritePngBitmap(FILE *fp,unsigned char *bitmap,unsigned int width,unsigned int height){	png_structp png_ptr=NULL;	png_infop info_ptr=NULL;	size_t y;	png_byte **row_pointers=NULL;	int pixel_size=1;	int depth=8;	if ((png_ptr=png_create_write_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL))==NULL) return(false);	if (((info_ptr=png_create_info_struct(png_ptr))==NULL) || setjmp(png_jmpbuf(png_ptr)))	{		png_destroy_write_struct(&png_ptr,&info_ptr);		return(false);	}	// Set image attributes	png_set_IHDR(png_ptr,info_ptr,width,height,depth,PNG_COLOR_TYPE_GRAY,PNG_INTERLACE_NONE,PNG_COMPRESSION_TYPE_DEFAULT,PNG_FILTER_TYPE_DEFAULT);	// Initialize rows of PNG	row_pointers=(png_byte**)png_malloc(png_ptr,height*sizeof(png_byte*));	for (y=0;y<height;++y)	{		png_byte *row=(png_byte*)png_malloc(png_ptr,sizeof(png_byte)*width*pixel_size);		row_pointers[y]=row;		memcpy(row,bitmap,width*pixel_size);		bitmap+=width*pixel_size;	}	// Write the image data to file	png_init_io(png_ptr,fp);	png_set_rows(png_ptr,info_ptr,row_pointers);	png_write_png(png_ptr,info_ptr,PNG_TRANSFORM_IDENTITY,NULL);	for (y=0;y<height;y++) png_free(png_ptr,row_pointers[y]);	png_free(png_ptr,row_pointers);	png_destroy_write_struct(&png_ptr,&info_ptr);	return true;}unsigned char* OpenUtility::CFontLoader::ReadPngBitmap(FILE *fp,unsigned int &width,unsigned int &height){	png_byte header[8];	// read the header	fread(header,1,8,fp);	if (png_sig_cmp(header,0,8)) return NULL;	png_structp png_ptr=NULL;	png_infop info_ptr=NULL;	png_infop end_info=NULL;	if ((png_ptr=png_create_read_struct(PNG_LIBPNG_VER_STRING,NULL,NULL,NULL))==NULL) return NULL;	if ((info_ptr=png_create_info_struct(png_ptr))==NULL)	{		png_destroy_read_struct(&png_ptr,(png_infopp)NULL,(png_infopp)NULL);		return NULL;	}	// create png info struct	if ((end_info=png_create_info_struct(png_ptr))==0)	{		png_destroy_read_struct(&png_ptr,&info_ptr,(png_infopp)NULL);		return NULL;	}	// the code in this if statement gets called if libpng encounters an error	if (setjmp(png_jmpbuf(png_ptr)))	{		png_destroy_read_struct(&png_ptr,&info_ptr,&end_info);		return NULL;	}	// Read the image data from file	int bit_depth,color_type;	unsigned long w,h;	png_init_io(png_ptr,fp);	png_set_sig_bytes(png_ptr,8);	png_read_info(png_ptr,info_ptr);	png_get_IHDR(png_ptr,info_ptr,&w,&h,&bit_depth,&color_type,NULL,NULL,NULL);	if ((color_type!=PNG_COLOR_TYPE_GRAY) || (bit_depth!=8))	{		png_destroy_read_struct(&png_ptr,&info_ptr,&end_info);		return NULL;	}	width=w;	height=h;	png_read_update_info(png_ptr,info_ptr);	int rowbytes=png_get_rowbytes(png_ptr,info_ptr);	png_byte *image_data;	if ((image_data=(png_byte*)malloc(rowbytes*h*sizeof(png_byte)+15))==NULL)	{		png_destroy_read_struct(&png_ptr,&info_ptr,&end_info);		return NULL;	}	png_bytep *row_pointers;	if ((row_pointers=(png_bytep*)malloc(h*sizeof(png_bytep)))==NULL)	{		png_destroy_read_struct(&png_ptr,&info_ptr,&end_info);		free(image_data);		return NULL;	}	for (unsigned long i=0;i<h;i++)		row_pointers[i]=image_data+i*rowbytes;	png_read_image(png_ptr,row_pointers);	png_destroy_read_struct(&png_ptr,&info_ptr,&end_info);	free(row_pointers);	return(image_data);}